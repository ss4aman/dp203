{"version":3,"file":"eventHubReceiver.js","sourceRoot":"","sources":["../../src/eventHubReceiver.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortController, AbortError, AbortSignalLike } from \"@azure/abort-controller\";\nimport {\n  Constants,\n  MessagingError,\n  RetryOperationType,\n  StandardAbortMessage,\n  retry,\n  translate,\n  RetryConfig,\n} from \"@azure/core-amqp\";\nimport {\n  EventContext,\n  OnAmqpEvent,\n  Receiver,\n  ReceiverOptions as RheaReceiverOptions,\n  types,\n} from \"rhea-promise\";\nimport { EventDataInternal, ReceivedEventData, fromRheaMessage } from \"./eventData\";\nimport { EventPosition, getEventPositionFilter } from \"./eventPosition\";\nimport { logErrorStackTrace, logger } from \"./log\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { EventHubConsumerOptions } from \"./models/private\";\nimport { LinkEntity } from \"./linkEntity\";\nimport { getRetryAttemptTimeoutInMs } from \"./util/retries\";\nimport { createAbortablePromise } from \"@azure/core-util\";\n\ninterface CreateReceiverOptions {\n  onMessage: OnAmqpEvent;\n  onError: OnAmqpEvent;\n  onClose: OnAmqpEvent;\n  onSessionError: OnAmqpEvent;\n  onSessionClose: OnAmqpEvent;\n  eventPosition?: EventPosition;\n}\n\n/**\n * A set of information about the last enqueued event of a partition, as observed by the consumer as\n * events are received from the Event Hubs service\n */\nexport interface LastEnqueuedEventProperties {\n  /**\n   * The sequence number of the event that was last enqueued into the Event Hub partition from which\n   * this event was received.\n   */\n  sequenceNumber?: number;\n  /**\n   * The date and time, in UTC, that the last event was enqueued into the Event Hub partition from\n   * which this event was received.\n   */\n  enqueuedOn?: Date;\n  /**\n   * The offset of the event that was last enqueued into the Event Hub partition from which\n   * this event was received.\n   */\n  offset?: string;\n  /**\n   * The date and time, in UTC, that the last event was retrieved from the Event Hub partition.\n   */\n  retrievedOn?: Date;\n}\n\n/**\n * Describes the EventHubReceiver that will receive event data from EventHub.\n * @internal\n */\nexport class EventHubReceiver extends LinkEntity {\n  /**\n   * The EventHub consumer group from which the receiver will\n   * receive messages. (Default: \"default\").\n   */\n  readonly consumerGroup: string;\n  /**\n   * The receiver runtime info.\n   */\n  private readonly runtimeInfo: LastEnqueuedEventProperties;\n  /**\n   * The Receiver ownerLevel.\n   */\n  private readonly ownerLevel?: number;\n  /**\n   * The event position in the partition at which to start receiving messages.\n   */\n  private readonly eventPosition: EventPosition;\n  /**\n   * Optional properties that can be set while creating\n   * the EventHubConsumer.\n   */\n  private readonly options: EventHubConsumerOptions;\n  /**\n   * The RHEA AMQP-based receiver link.\n   */\n  private _receiver?: Receiver;\n  /**\n   * The error handler provided by the batching or streaming flavors of receive operations on the `EventHubConsumer`\n   */\n  private _onError?: (error: MessagingError | Error) => void;\n  /**\n   * The sequence number of the most recently received AMQP message.\n   */\n  private _checkpoint: number = -1;\n  /**\n   * Indicates if messages are being received from this receiver.\n   */\n  private _isReceivingMessages: boolean = false;\n  /**\n   * Indicated if messages are being received in streaming mode.\n   */\n  private _isStreaming: boolean = false;\n  /**\n   * Denotes if close() was called on this receiver\n   */\n  private _isClosed: boolean = false;\n\n  private readonly queue: ReceivedEventData[] = [];\n  /**\n   * Returns sequenceNumber of the last event received from the service. This will not match the\n   * last event received by `EventHubConsumer` when the `queue` is not empty\n   * @readonly\n   */\n  get checkpoint(): number {\n    return this._checkpoint;\n  }\n\n  /**\n   * Indicates if messages are being received from this receiver.\n   * @readonly\n   */\n  get isReceivingMessages(): boolean {\n    return this._isReceivingMessages;\n  }\n\n  /**\n   * Indicates if the receiver has been closed.\n   */\n  get isClosed(): boolean {\n    return this._isClosed;\n  }\n\n  /**\n   * The last enqueued event information. This property will only\n   * be enabled when `trackLastEnqueuedEventProperties` option is set to true\n   * @readonly\n   */\n  public get lastEnqueuedEventProperties(): LastEnqueuedEventProperties {\n    return this.runtimeInfo;\n  }\n\n  /**\n   * Instantiates a receiver that can be used to receive events over an AMQP receiver link in\n   * either batching or streaming mode.\n   * @param context -        The connection context corresponding to the EventHubClient instance\n   * @param consumerGroup -  The consumer group from which the receiver should receive events from.\n   * @param partitionId -    The Partition ID from which to receive.\n   * @param eventPosition -  The position in the stream from where to start receiving events.\n   * @param options -      Receiver options.\n   */\n  constructor(\n    context: ConnectionContext,\n    consumerGroup: string,\n    partitionId: string,\n    eventPosition: EventPosition,\n    options: EventHubConsumerOptions = {}\n  ) {\n    super(context, {\n      partitionId: partitionId,\n      name: context.config.getReceiverAddress(partitionId, consumerGroup),\n    });\n    this.consumerGroup = consumerGroup;\n    this.address = context.config.getReceiverAddress(partitionId, this.consumerGroup);\n    this.audience = context.config.getReceiverAudience(partitionId, this.consumerGroup);\n    this.ownerLevel = options.ownerLevel;\n    this.eventPosition = eventPosition;\n    this.options = options;\n    this.runtimeInfo = {};\n  }\n\n  private _onAmqpMessage(context: EventContext): void {\n    if (!context.message) {\n      return;\n    }\n    const data: EventDataInternal = fromRheaMessage(\n      context.message,\n      !!this.options.skipParsingBodyAsJson\n    );\n    const rawMessage = data.getRawAmqpMessage();\n    const receivedEventData: ReceivedEventData = {\n      body: data.body,\n      properties: data.properties,\n      offset: data.offset!,\n      sequenceNumber: data.sequenceNumber!,\n      enqueuedTimeUtc: data.enqueuedTimeUtc!,\n      partitionKey: data.partitionKey!,\n      systemProperties: data.systemProperties,\n      getRawAmqpMessage() {\n        return rawMessage;\n      },\n    };\n    if (data.correlationId != null) {\n      receivedEventData.correlationId = data.correlationId;\n    }\n    if (data.contentType != null) {\n      receivedEventData.contentType = data.contentType;\n    }\n    if (data.messageId != null) {\n      receivedEventData.messageId = data.messageId;\n    }\n\n    this._checkpoint = receivedEventData.sequenceNumber;\n\n    if (this.options.trackLastEnqueuedEventProperties && data) {\n      this.runtimeInfo.sequenceNumber = data.lastSequenceNumber;\n      this.runtimeInfo.enqueuedOn = data.lastEnqueuedTime;\n      this.runtimeInfo.offset = data.lastEnqueuedOffset;\n      this.runtimeInfo.retrievedOn = data.retrievalTime;\n    }\n\n    if (this._isStreaming) {\n      this._addCredit(1);\n    }\n    this.queue.push(receivedEventData);\n  }\n\n  private _onAmqpError(context: EventContext): void {\n    const rheaReceiver = this._receiver || context.receiver;\n    const amqpError = rheaReceiver && rheaReceiver.error;\n    logger.verbose(\n      \"[%s] 'receiver_error' event occurred on the receiver '%s' with address '%s'. \" +\n        \"The associated error is: %O\",\n      this._context.connectionId,\n      this.name,\n      this.address,\n      amqpError\n    );\n\n    if (this._onError && amqpError) {\n      const error = translate(amqpError);\n      logErrorStackTrace(error);\n      this._onError(error);\n    }\n  }\n\n  private _onAmqpSessionError(context: EventContext): void {\n    const sessionError = context.session && context.session.error;\n    logger.verbose(\n      \"[%s] 'session_error' event occurred on the session of receiver '%s' with address '%s'. \" +\n        \"The associated error is: %O\",\n      this._context.connectionId,\n      this.name,\n      this.address,\n      sessionError\n    );\n\n    if (this._onError && sessionError) {\n      const error = translate(sessionError);\n      logErrorStackTrace(error);\n      this._onError(error);\n    }\n  }\n\n  private async _onAmqpClose(context: EventContext): Promise<void> {\n    const rheaReceiver = this._receiver || context.receiver;\n    logger.verbose(\n      \"[%s] 'receiver_close' event occurred on the receiver '%s' with address '%s'. \" +\n        \"Value for isItselfClosed on the receiver is: '%s' \" +\n        \"Value for isConnecting on the session is: '%s'.\",\n      this._context.connectionId,\n      this.name,\n      this.address,\n      rheaReceiver ? rheaReceiver.isItselfClosed().toString() : undefined,\n      this.isConnecting\n    );\n    if (rheaReceiver && !this.isConnecting) {\n      // Call close to clean up timers & other resources\n      await rheaReceiver.close().catch((err) => {\n        logger.verbose(\n          \"[%s] Error when closing receiver [%s] after 'receiver_close' event: %O\",\n          this._context.connectionId,\n          this.name,\n          err\n        );\n      });\n    }\n  }\n\n  private async _onAmqpSessionClose(context: EventContext): Promise<void> {\n    const rheaReceiver = this._receiver || context.receiver;\n    logger.verbose(\n      \"[%s] 'session_close' event occurred on the session of receiver '%s' with address '%s'. \" +\n        \"Value for isSessionItselfClosed on the session is: '%s' \" +\n        \"Value for isConnecting on the session is: '%s'.\",\n      this._context.connectionId,\n      this.name,\n      this.address,\n      rheaReceiver ? rheaReceiver.isSessionItselfClosed().toString() : undefined,\n      this.isConnecting\n    );\n    if (rheaReceiver && !this.isConnecting) {\n      // Call close to clean up timers & other resources\n      await rheaReceiver.close().catch((err) => {\n        logger.verbose(\n          \"[%s] Error when closing receiver [%s] after 'session_close' event: %O\",\n          this._context.connectionId,\n          this.name,\n          err\n        );\n      });\n    }\n  }\n\n  abort(): Promise<void> {\n    // Cancellation is user-intended, so log to info instead of warning.\n    logger.info(\n      `[${this._context.connectionId}] The receive operation on the Receiver \"${this.name}\" with address \"${this.address}\" has been cancelled by the user.`\n    );\n    this._onError?.(new AbortError(StandardAbortMessage));\n    return this.close();\n  }\n\n  /**\n   * Clears the user-provided handlers and updates the receiving messages flag.\n   */\n  clearHandlers(): void {\n    if (!this) return;\n    this._onError = undefined;\n    this._isReceivingMessages = false;\n    this._isStreaming = false;\n  }\n\n  /**\n   * Closes the underlying AMQP receiver.\n   */\n  async close(): Promise<void> {\n    this.clearHandlers();\n    if (!this._receiver) {\n      return;\n    }\n    const receiverLink = this._receiver;\n    this._deleteFromCache();\n    return this._closeLink(receiverLink)\n      .catch((err) => {\n        logger.warning(\n          `[${this._context.connectionId}] An error occurred while closing receiver ${this.name}: ${err?.name}: ${err?.message}`\n        );\n        logErrorStackTrace(err);\n        throw err;\n      })\n      .finally(() => {\n        this._isClosed = true;\n      });\n  }\n\n  /**\n   * Determines whether the AMQP receiver link is open. If open then returns true else returns false.\n   * @returns boolean\n   */\n  isOpen(): boolean {\n    const result = Boolean(this._receiver && this._receiver.isOpen());\n    logger.verbose(\n      \"[%s] Receiver '%s' with address '%s' is open? -> %s\",\n      this._context.connectionId,\n      this.name,\n      this.address,\n      result\n    );\n    return result;\n  }\n\n  private _addCredit(credit: number): void {\n    this._receiver?.addCredit(credit);\n  }\n\n  private _deleteFromCache(): void {\n    this._receiver = undefined;\n    delete this._context.receivers[this.name];\n    logger.verbose(\n      \"[%s] Deleted the receiver '%s' from the client cache.\",\n      this._context.connectionId,\n      this.name\n    );\n  }\n\n  /**\n   * Creates a new AMQP receiver under a new AMQP session.\n   */\n  async initialize({\n    abortSignal,\n    timeoutInMs,\n  }: {\n    abortSignal: AbortSignalLike | undefined;\n    timeoutInMs: number;\n  }): Promise<void> {\n    try {\n      const isOpen = this.isOpen();\n      if (this.isConnecting || isOpen) {\n        logger.verbose(\n          \"[%s] The receiver '%s' with address '%s' is open -> %s and is connecting -> %s. Hence not reconnecting.\",\n          this._context.connectionId,\n          this.name,\n          this.address,\n          isOpen,\n          this.isConnecting\n        );\n        return;\n      }\n      this.isConnecting = true;\n\n      logger.verbose(\n        \"[%s] The receiver '%s' with address '%s' is trying to connect\",\n        this._context.connectionId,\n        this.name,\n        this.address\n      );\n\n      // Wait for the connectionContext to be ready to open the link.\n      await this._context.readyToOpenLink({ abortSignal });\n      await this._negotiateClaim({ setTokenRenewal: false, abortSignal, timeoutInMs });\n\n      const receiverOptions: CreateReceiverOptions = {\n        onClose: (context) => this._onAmqpClose(context),\n        onError: (context) => this._onAmqpError(context),\n        onMessage: (context) => this._onAmqpMessage(context),\n        onSessionClose: (context) => this._onAmqpSessionClose(context),\n        onSessionError: (context) => this._onAmqpSessionError(context),\n      };\n      if (this.checkpoint > -1) {\n        receiverOptions.eventPosition = { sequenceNumber: this.checkpoint };\n      }\n      const options = this._createReceiverOptions(receiverOptions);\n\n      logger.verbose(\n        \"[%s] Trying to create receiver '%s' with options %O\",\n        this._context.connectionId,\n        this.name,\n        options\n      );\n      this._receiver = await this._context.connection.createReceiver({ ...options, abortSignal });\n      this.isConnecting = false;\n      logger.verbose(\n        \"[%s] Receiver '%s' created with receiver options: %O\",\n        this._context.connectionId,\n        this.name,\n        options\n      );\n      // store the underlying link in a cache\n      this._context.receivers[this.name] = this;\n\n      this._ensureTokenRenewal();\n    } catch (err) {\n      this.isConnecting = false;\n      const error = translate(err);\n      logger.warning(\n        \"[%s] An error occurred while creating the receiver '%s': %s\",\n        this._context.connectionId,\n        this.name,\n        `${error?.name}: ${error?.message}`\n      );\n      logErrorStackTrace(err);\n      throw error;\n    }\n  }\n\n  /**\n   * Creates the options that need to be specified while creating an AMQP receiver link.\n   */\n  private _createReceiverOptions(options: CreateReceiverOptions): RheaReceiverOptions {\n    const receiverOptions: RheaReceiverOptions = {\n      name: this.name,\n      autoaccept: true,\n      source: {\n        address: this.address,\n      },\n      credit_window: 0,\n      onMessage: options.onMessage,\n      onError: options.onError,\n      onClose: options.onClose,\n      onSessionError: options.onSessionError,\n      onSessionClose: options.onSessionClose,\n    };\n\n    if (typeof this.ownerLevel === \"number\") {\n      receiverOptions.properties = {\n        [Constants.attachEpoch]: types.wrap_long(this.ownerLevel),\n      };\n    }\n\n    if (this.options.trackLastEnqueuedEventProperties) {\n      receiverOptions.desired_capabilities = Constants.enableReceiverRuntimeMetricName;\n    }\n\n    const eventPosition = options.eventPosition || this.eventPosition;\n    if (eventPosition) {\n      // Set filter on the receiver if event position is specified.\n      const filterClause = getEventPositionFilter(eventPosition);\n      if (filterClause) {\n        (receiverOptions.source as any).filter = {\n          \"apache.org:selector-filter:string\": types.wrap_described(filterClause, 0x468c00000004),\n        };\n      }\n    }\n    return receiverOptions;\n  }\n\n  /**\n   * Returns a promise that resolves to an array of events received from the service.\n   *\n   * @param maxMessageCount - The maximum number of messages to receive.\n   * @param maxWaitTimeInSeconds - The maximum amount of time to wait to build up the requested message count;\n   * If not provided, it defaults to 60 seconds.\n   * @param abortSignal - An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   *\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   * @throws MessagingError if an error is encountered while receiving a message.\n   * @throws Error if the underlying connection or receiver has been closed.\n   * Create a new EventHubConsumer using the EventHubClient createConsumer method.\n   * @throws Error if the receiver is already receiving messages.\n   */\n  async receiveBatch(\n    maxMessageCount: number,\n    maxWaitTimeInSeconds: number = 60,\n    abortSignal?: AbortSignalLike\n  ): Promise<ReceivedEventData[]> {\n    this._isReceivingMessages = true;\n    this._isStreaming = false;\n\n    const cleanupBeforeAbort = (): Promise<void> => {\n      logger.info(\n        `[${this._context.connectionId}] The request operation on the Receiver \"${this.name}\" with address \"${this.address}\" has been cancelled by the user.`\n      );\n      return this.close();\n    };\n\n    const tryOpenLink = (): Promise<void> =>\n      createAbortablePromise(\n        (resolve, reject) =>\n          this.initialize({\n            abortSignal,\n            timeoutInMs: getRetryAttemptTimeoutInMs(this.options.retryOptions),\n          })\n            .then(resolve)\n            .catch(reject),\n        {\n          abortSignal,\n          abortErrorMsg: StandardAbortMessage,\n        }\n      );\n\n    /** The time to wait in ms before attempting to read from the queue */\n    const readIntervalWaitTimeInMs = 20;\n\n    const retrieveEvents = (): Promise<ReceivedEventData[]> => {\n      const eventsToRetrieveCount = Math.max(maxMessageCount - this.queue.length, 0);\n      logger.verbose(\n        \"[%s] Receiver '%s' already has %d events and wants to receive %d more events.\",\n        this._context.connectionId,\n        this.name,\n        this.queue.length,\n        eventsToRetrieveCount\n      );\n      if (abortSignal?.aborted) {\n        cleanupBeforeAbort();\n        return Promise.reject(new AbortError(StandardAbortMessage));\n      }\n      return this._isClosed || this._context.wasConnectionCloseCalled\n        ? Promise.resolve(this.queue.splice(0))\n        : eventsToRetrieveCount === 0\n        ? Promise.resolve(this.queue.splice(0, maxMessageCount))\n        : new Promise<void>((resolve, reject) => {\n            this._onError = (err) => {\n              if (err.name === \"AbortError\") {\n                cleanupBeforeAbort();\n              }\n              this.clearHandlers();\n              reject(err);\n            };\n\n            // eslint-disable-next-line promise/catch-or-return\n            tryOpenLink()\n              .then(() => {\n                // add credits\n                const existingCredits = this._receiver?.credit ?? 0;\n                const creditsToAdd = Math.max(eventsToRetrieveCount - existingCredits, 0);\n                this._addCredit(creditsToAdd);\n                logger.verbose(\n                  \"[%s] Setting the wait timer for %d seconds for receiver '%s'.\",\n                  this._context.connectionId,\n                  maxWaitTimeInSeconds,\n                  this.name\n                );\n                return; // to make eslint happy\n              })\n              .then(() =>\n                waitForEvents(\n                  maxMessageCount,\n                  maxWaitTimeInSeconds * 1000,\n                  readIntervalWaitTimeInMs,\n                  this.queue,\n                  {\n                    abortSignal,\n                    cleanupBeforeAbort,\n                    receivedAfterWait: () =>\n                      logger.info(\n                        \"[%s] Batching Receiver '%s', %d messages received within %d seconds.\",\n                        this._context.connectionId,\n                        this.name,\n                        Math.min(maxMessageCount, this.queue.length),\n                        maxWaitTimeInSeconds\n                      ),\n                    receivedAlready: () =>\n                      logger.info(\n                        \"[%s] Batching Receiver '%s', %d messages already received.\",\n                        this._context.connectionId,\n                        this.name,\n                        maxMessageCount,\n                        maxWaitTimeInSeconds\n                      ),\n                    receivedNone: () =>\n                      logger.info(\n                        \"[%s] Batching Receiver '%s', no messages received when max wait time in seconds %d is over.\",\n                        this._context.connectionId,\n                        this.name,\n                        maxWaitTimeInSeconds\n                      ),\n                  }\n                )\n              )\n              .catch(reject)\n              .then(resolve);\n          })\n            .then(() => this.queue.splice(0, maxMessageCount))\n            .finally(this.clearHandlers);\n    };\n\n    return retry(\n      Object.defineProperties(\n        {\n          operation: retrieveEvents,\n          operationType: RetryOperationType.receiveMessage,\n          abortSignal: abortSignal,\n          retryOptions: this.options.retryOptions ?? {},\n        },\n        {\n          connectionId: {\n            enumerable: true,\n            get: () => this._context.connectionId,\n          },\n          connectionHost: {\n            enumerable: true,\n            get: () => this._context.config.host,\n          },\n        }\n      ) as RetryConfig<ReceivedEventData[]>\n    );\n  }\n}\n\nfunction delay(\n  waitTimeInMs: number,\n  options?: {\n    abortSignal?: AbortSignalLike;\n    cleanupBeforeAbort?: () => void;\n    abortErrorMsg?: string;\n  }\n): Promise<void> {\n  let token: ReturnType<typeof setTimeout>;\n  return createAbortablePromise<void>((resolve) => {\n    token = setTimeout(resolve, waitTimeInMs);\n  }, options).finally(() => clearTimeout(token));\n}\n\nexport function checkOnInterval(\n  waitTimeInMs: number,\n  check: () => boolean,\n  options?: {\n    abortSignal?: AbortSignalLike;\n    cleanupBeforeAbort?: () => void;\n    abortErrorMsg?: string;\n  }\n): Promise<void> {\n  let token: ReturnType<typeof setInterval>;\n  return createAbortablePromise<void>((resolve) => {\n    token = setInterval(() => {\n      if (check()) {\n        resolve();\n      }\n    }, waitTimeInMs);\n  }, options).finally(() => clearInterval(token));\n}\n\n/**\n * Returns a promise that will resolve when it is time to read from the queue\n * @param maxEventCount - The maximum number of events to receive.\n * @param maxWaitTimeInMs - The maximum time to wait in ms for the queue to contain any events.\n * @param readIntervalWaitTimeInMs - The time interval to wait in ms before checking the queue.\n * @param queue - The queue to read from.\n * @param options - The options bag.\n * @returns a promise that will resolve when it is time to read from the queue\n */\nexport function waitForEvents(\n  maxEventCount: number,\n  maxWaitTimeInMs: number,\n  readIntervalWaitTimeInMs: number,\n  queue: unknown[],\n  options?: {\n    abortSignal?: AbortSignalLike;\n    cleanupBeforeAbort?: () => void;\n    receivedAfterWait?: () => void;\n    receivedAlready?: () => void;\n    receivedNone?: () => void;\n  }\n): Promise<void> {\n  const {\n    abortSignal: clientAbortSignal,\n    cleanupBeforeAbort,\n    receivedNone,\n    receivedAfterWait,\n    receivedAlready,\n  } = options ?? {};\n  const aborter = new AbortController();\n  const { signal: abortSignal } = new AbortController([\n    aborter.signal,\n    ...(clientAbortSignal ? [clientAbortSignal] : []),\n  ]);\n  const updatedOptions = {\n    abortSignal,\n    abortErrorMsg: StandardAbortMessage,\n    cleanupBeforeAbort: () => {\n      if (clientAbortSignal?.aborted) {\n        cleanupBeforeAbort?.();\n      }\n    },\n  };\n  return queue.length >= maxEventCount\n    ? Promise.resolve().then(receivedAlready)\n    : Promise.race([\n        checkOnInterval(readIntervalWaitTimeInMs, () => queue.length > 0, updatedOptions)\n          .then(() => delay(readIntervalWaitTimeInMs, updatedOptions))\n          .then(receivedAfterWait),\n        delay(maxWaitTimeInMs, updatedOptions).then(receivedNone),\n      ]).finally(() => aborter.abort());\n}\n"]}